'''
Eric Larsen's Genome Peri Module
Contains classes and functions for handling SNP data in TXT format
generated by 23&Me and Ancestry.com
2021
'''
#import dependencies
from re import finditer as SUBSTRING_ITERATOR
#8/29 - import single function instead of whole 're' module

'''SNP_GENOME class definition and associated functions'''
#8/27/21 - this is working
#8/29/21 TO DO: Chromosome read counting
class SNP_GENOME:
    #Object definition
    #Subject Name
    #Read TXT
    #TXT type (Ancestry or 23&Me)
    def __init__(self, name_string, TXT_address, TXT_TYPE):
        #Set variables
        self.NAME = name_string
        self.GENOME = {}
        self.CHROMOSOME_COUNT_LOG = {}
        self.CHROMOSOME_TOTAL = 0
        #set object data source
        if TXT_TYPE == 0: self.SOURCE = '23&Me'
        if TXT_TYPE == 1: self.SOURCE = 'ANCESTRY.com'
        #TO DO - support additional sources (and other species?)
        #LOAD TXT FILE
        '''Both file types have Read-me text that starts with '#'
        23&me has 20 lines (from files generated in 2017 and 2018)
        23&me has 4 columns (rsid,chromosome, position, and genotype)
        Ancestry data has 18+1 lines - header does not start with '#' (file generated in 2018)
        Ancestry has 5 columns (rsid,chromosome,position,allele1,allele2)'''
        GENOMEFILE = open(TXT_address)
        RAWTXTDATA = GENOMEFILE.readlines()
        GENOMEFILE.close()
        #RAWTXTDATA is every line including \t and \n
        #convert this data to a dictionary
        #structure {'rs###':[C,P,'A1','A2']}
        for N,S in enumerate(RAWTXTDATA):
            #load individual data line
            LINE = RAWTXTDATA[N]
            #Validator for chromosome read counting
            ENTRY_CONFIRMED = 0
            #test for '#' character
            if LINE[0] != '#':
                #strip '\n' from LINE
                NEWLINE_START = LINE.find('\n')
                TABBED_LINE = LINE[0:NEWLINE_START]
                #sort data by '\t' detection. Adapted from
                #https://stackoverflow.com/questions/4664850/how-to-find-all-occurrences-of-a-substring
                TAB_INDEX = [m.start() for m in SUBSTRING_ITERATOR('\t',TABBED_LINE)]
                #23&me formating
                #8/29 DONE: have this clean up chromosome IDs
                #use Integers 1-22, 23 for 'X', 24 for 'Y', and 26 for 'MT'
                #TO DO - get # of reads per chromosome
                #get a count of chromosomes - for potential future compatibiltiy with nonhuman data
                ChromosomeLookup = {'X':23, 'Y':24, 'MT':26}
                if TXT_TYPE == 0:
                    RS_key = LINE[0:TAB_INDEX[0]]
                    #Chromosome can be 'X' 'Y' or 'mt' so convert it to INT
                    CHROMOSOME = TABBED_LINE[TAB_INDEX[0]+1:TAB_INDEX[1]]
                    if CHROMOSOME == 'X' or CHROMOSOME =='Y' or CHROMOSOME =='MT':
                        CHROMOSOME = ChromosomeLookup[CHROMOSOME]
                    else:
                        CHROMOSOME = int(CHROMOSOME)

                    #build self.GENOME dictionary entry from 23&Me format
                    GENE_POSITION = int(TABBED_LINE[TAB_INDEX[1]+1:TAB_INDEX[2]])
                    allele1 = TABBED_LINE[TAB_INDEX[2]+1:TAB_INDEX[2]+2]
                    allele2 = TABBED_LINE[TAB_INDEX[2]+2:TAB_INDEX[2]+3]
                    RS_list = [CHROMOSOME, GENE_POSITION, allele1, allele2]
                    DICT_ENTRY = {RS_key:RS_list}
                    ENTRY_CONFIRMED = 1
                    #update self.GENOME dictionary
                    self.GENOME.update(DICT_ENTRY)
                    try:
                        CHR_READ_COUNT = self.CHROMOSOME_COUNT_LOG[CHROMOSOME]
                        CHR_READ_COUNT = CHR_READ_COUNT +1
                        NEW_CHR_READ_ENTRY = {CHROMOSOME:CHR_READ_COUNT}
                        self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                    #expect a KeyError if this Chromosome is not logged
                    except KeyError:
                        NEW_CHR_READ_ENTRY = {CHROMOSOME:1}
                        self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                        #Increment Chromosome read counter
                        self.CHROMOSOME_TOTAL = self.CHROMOSOME_TOTAL + 1 

                #Ancestry.com formating
                if TXT_TYPE == 1:
                    RS_key = TABBED_LINE[0:TAB_INDEX[0]]
                    #Detect header line
                    if RS_key != 'rsid':
                        CHROMOSOME = TABBED_LINE[TAB_INDEX[0]+1:TAB_INDEX[1]]
                        #Ancestry IDs chromosomes with an int by default
                        #TO DO: have separate ids for 'X1' and 'X2' (lack datasets to be definitive)
                        CHROMOSOME = int(CHROMOSOME)
                        #Consolidate all 'X' chromosome entries into one int ID
                        if CHROMOSOME == 25:
                            CHROMOSOME = 23

                        #build self.GENOME dictionary entry from Ancestry.com format
                        GENE_POSITION = int(TABBED_LINE[TAB_INDEX[1]+1:TAB_INDEX[2]])
                        allele1 = TABBED_LINE[TAB_INDEX[2]+1:TAB_INDEX[3]]
                        allele2 = TABBED_LINE[TAB_INDEX[3]+1:TAB_INDEX[3]+2]
                        RS_list = [CHROMOSOME, GENE_POSITION, allele1, allele2]
                        DICT_ENTRY = {RS_key:RS_list}
                        ENTRY_CONFIRMED = 1
                        #update self.GENOME dictionary
                        self.GENOME.update(DICT_ENTRY)
                        #Check if any reads have been made for this chromosome
                        try:
                            CHR_READ_COUNT = self.CHROMOSOME_COUNT_LOG[CHROMOSOME]
                            CHR_READ_COUNT = CHR_READ_COUNT +1
                            NEW_CHR_READ_ENTRY = {CHROMOSOME:CHR_READ_COUNT}
                            self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                        #expect a KeyError if this Chromosome is not logged
                        except KeyError:
                            NEW_CHR_READ_ENTRY = {CHROMOSOME:1}
                            self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                            #Increment Chromosome read counter
                            self.CHROMOSOME_TOTAL = self.CHROMOSOME_TOTAL + 1


        #make list of RSIDs
        self.RSINDEX = list(self.GENOME)

        #determine number of chromosomes
        #self.CHROMOSOME_TOTAL = len(list(self.CHROMOSOME_COUNT_LOG))
    #end of INIT
    
    #This function will go through each entry and score sequence quality
    #IE: if SNP has 2 alleles, both either 'A','C','G',or 'T' it is scored 1, otherwise it is 0.5 or 0
    #TO DO: Add support for individual chromosomes    
    def SEQUENCEQC(self):
        self.TOTAL_READS = len(self.GENOME)
        self.READ_SCORE = 0
        EXPECTED_BASES = ' ATCG'
        for N,S in enumerate(self.RSINDEX):
            RS_key = self.RSINDEX[N]
            SNP_READ = self.GENOME[RS_key] 
            SNP_SCORE = 0
            a1 = SNP_READ[2]
            a2 = SNP_READ[3]
            A1_QC = EXPECTED_BASES.find(a1)
            A2_QC = EXPECTED_BASES.find(a2)
            if A1_QC > 0:
                SNP_SCORE = SNP_SCORE + 0.5
            if A2_QC > 0:
                SNP_SCORE = SNP_SCORE + 0.5
            self.READ_SCORE = self.READ_SCORE + SNP_SCORE
        self.READ_DEPTH = self.READ_SCORE / self.TOTAL_READS
        #8/27/21 this works
#end of SNP_GENOME object & functions

'''Functions for handling SNP_GENOME objects:'''

#Convert two genomes into a set, find the intersection,
# and return a list of common rsids
def SNP_SET_INTERSECT(subjectA,subjectB):
    RSID_A_set = set(subjectA.RSINDEX)
    RSID_B_set = set(subjectB.RSINDEX)
    INTERSECT_SET = RSID_A_set.intersection(RSID_B_set)
    INTERSECT_LIST = list(INTERSECT_SET)
    return INTERSECT_LIST

#Makes an identity score between 2 SNPs pulled from SNP_GENOME.GENOME{}
#to be called by subsequent functions
def SNP_GENOTYPE_SCORE(SNP_A,SNP_B):
    #input format: [C,P,'A1','A2']
    FINAL_SCORE = 0
    #Subject A data
    SUBJECT_A_CHROMOSOME = SNP_A[0]
    SUBJECT_A_POSITION = SNP_A[1]
    SUBJECT_A_ALLELE_1 = SNP_A[2]
    SUBJECT_A_ALLELE_2 = SNP_A[3]
    #Subject B data
    SUBJECT_B_CHROMOSOME = SNP_B[0]
    SUBJECT_B_POSITION = SNP_B[1]
    SUBJECT_B_ALLELE_1 = SNP_B[2]
    SUBJECT_B_ALLELE_2 = SNP_B[3]
    #Confirm position before proceeding
    if SUBJECT_A_POSITION == SUBJECT_B_POSITION and SUBJECT_A_CHROMOSOME == SUBJECT_B_CHROMOSOME:
        #check for exact mstch
        if (SUBJECT_A_ALLELE_1 + SUBJECT_A_ALLELE_2) == (SUBJECT_B_ALLELE_1 + SUBJECT_B_ALLELE_2):
            FINAL_SCORE = 1
        else:
            ScoreAllele1_1 = int(SUBJECT_A_ALLELE_1 == SUBJECT_B_ALLELE_1)
            ScoreAllele1_2 = int(SUBJECT_A_ALLELE_1 == SUBJECT_B_ALLELE_2)
            ScoreAllele2_1 = int(SUBJECT_A_ALLELE_2 == SUBJECT_B_ALLELE_1)
            ScoreAllele2_2 = int(SUBJECT_A_ALLELE_2 == SUBJECT_B_ALLELE_2)
            FINAL_SCORE = 0.25*(ScoreAllele1_1 + ScoreAllele1_2 + ScoreAllele2_1 + ScoreAllele2_2)    
    return FINAL_SCORE
#8/28 this works

#Compare 2 whole SNP_GENOMES
def GENOME_COMPARE(subjectA,subjectB):
    MATCH_LIST = SNP_SET_INTERSECT(subjectA,subjectB)
    MATCH_SIZE = len(MATCH_LIST)
    MATCH_DEPTH_A = MATCH_SIZE / subjectA.TOTAL_READS
    MATCH_DEPTH_B = MATCH_SIZE / subjectB.TOTAL_READS
    MATCH_SCORE = 0
    for N,S in enumerate(MATCH_LIST):
        RS_QUERY = MATCH_LIST[N]
        SNP_A = subjectA.GENOME[RS_QUERY]
        SNP_B = subjectB.GENOME[RS_QUERY]
        SINGLE_SNP_SCORE = SNP_GENOTYPE_SCORE(SNP_A,SNP_B)
        MATCH_SCORE = MATCH_SCORE + SINGLE_SNP_SCORE
    IDENTITY_SCORE = MATCH_SCORE / MATCH_SIZE
    MATCH_RESULT = [f'{subjectA.NAME}:{subjectB.NAME}',MATCH_SCORE,MATCH_SIZE,IDENTITY_SCORE,MATCH_DEPTH_A,MATCH_DEPTH_B]
    return MATCH_RESULT
#8/27 this works

#Compare 2 SNP_GENOMES by chromosome - 8/29 WORK IN PROGRESS
def CHROMOSOME_COMPARE(subjectA,subjectB):
    #To Do: confirm both subjects have the same # of chromosomes to compare
    #use sets to find overlapping rsids
    MATCH_LIST = SNP_SET_INTERSECT(subjectA,subjectB)
    '''Note:
        23&Me data labels chromosomes 1-22,'X','Y', and 'MT'
        Ancestry labels are 1-22,23&25 ,24 , and 26
        This could be because the 23&me files I have are from males
        while the Ancestry file is from a female
    '''
    #8/29 - this is now addressed in the SNP_GENOME _init_
    #all instances now have uniform int ID for chromosomes
    #use a dictionary to convert int to string for user display later
    #ie {23:'X', 24:'Y', 26:'MT'}
    #To do- use each SNP_GENOME's chromosome listing (WIP)
    #to get read sizes and match deptsh
    for N,S in enumerate(MATCH_LIST):
        RS_QUERY = MATCH_LIST[N]
        SNP_A = subjectA.GENOME[RS_QUERY]
        SNP_B = subjectB.GENOME[RS_QUERY]
        
    return CHR_SCORE_INDEX
#End of SNP_GENOME comparison functions

'''Quick module test'''
def say_hello():
    print('Test Output')
#8/9 this works - module must be in Python38\Lib\site-packages

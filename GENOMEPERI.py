'''
Eric Larsen's Genome Peri Module
Contains classes and functions for handling SNP data in TXT format
generated by 23&Me and Ancestry.com
2021
'''
#Individual Genome Class
import re

#8/27/21 - this is working well
class SNP_GENOME:
    #Object definition
    #Subject Name
    #Read TXT
    #TXT type (Ancestry or 23&Me)
    def __init__(self, name_string, TXT_address, TXT_TYPE):
        self.NAME = name_string
        self.GENOME = {}
        #LOAD TXT FILE
        '''Both file types have Read-me text that starts with '#'
        23&me has 20 lines (from files generated in 2017 and 2018)
        23&me has 4 columns (rsid,chromosome, position, and genotype)
        Ancestry data has 18+1 lines - header does not start with '#' (file generated in 2018)
        Ancestry has 5 columns (rsid,chromosome,position,allele1,allele2)'''
        GENOMEFILE = open(TXT_address)
        RAWTXTDATA = GENOMEFILE.readlines()
        GENOMEFILE.close()
        #RAWTXTDATA is every line including \t and \n
        #convert this data to a dictionary
        #structure {'rs###':[C,P,'A1','A2']}
        for N,S in enumerate(RAWTXTDATA):
            #individual data line
            LINE = RAWTXTDATA[N]
            #test for '#' character
            if LINE[0] != '#':
                #strip '\n' from LINE
                NEWLINE_START = LINE.find('\n')
                TABBED_LINE = LINE[0:NEWLINE_START]
                #sort data by '\t' detection. Adapted from
                #https://stackoverflow.com/questions/4664850/how-to-find-all-occurrences-of-a-substring
                TAB_INDEX = [m.start() for m in re.finditer('\t',TABBED_LINE)]
                #23&me formating
                if TXT_TYPE == 0:
                    self.SOURCE = '23&Me'
                    RS_key = LINE[0:TAB_INDEX[0]]
                    #Chromosome can be 'X' 'Y' or 'mt' so do not make it an INT
                    CHROMOSOME = TABBED_LINE[TAB_INDEX[0]+1:TAB_INDEX[1]]
                    GENE_POSITION = int(TABBED_LINE[TAB_INDEX[1]+1:TAB_INDEX[2]])
                    allele1 = TABBED_LINE[TAB_INDEX[2]+1:TAB_INDEX[2]+2]
                    allele2 = TABBED_LINE[TAB_INDEX[2]+2:TAB_INDEX[2]+3]
                    RS_list = [CHROMOSOME, GENE_POSITION, allele1, allele2]
                    DICT_ENTRY = {RS_key:RS_list}
                    self.GENOME.update(DICT_ENTRY)

                #Ancestry.com formating
                if TXT_TYPE == 1:
                    self.SOURCE = 'ANCESTRY.com'
                    RS_key = TABBED_LINE[0:TAB_INDEX[0]]
                    #Detect header line
                    if RS_key != 'rsid':
                        CHROMOSOME = TABBED_LINE[TAB_INDEX[0]+1:TAB_INDEX[1]]
                        GENE_POSITION = int(TABBED_LINE[TAB_INDEX[1]+1:TAB_INDEX[2]])
                        allele1 = TABBED_LINE[TAB_INDEX[2]+1:TAB_INDEX[3]]
                        allele2 = TABBED_LINE[TAB_INDEX[3]+1:TAB_INDEX[3]+2]
                        RS_list = [CHROMOSOME, GENE_POSITION, allele1, allele2]
                        DICT_ENTRY = {RS_key:RS_list}
                        self.GENOME.update(DICT_ENTRY)
        #make list of RSIDs
        self.RSINDEX = list(self.GENOME)
    #end of INIT
    
    #This function will go through each entry and score sequence quality
    #IE: if SNP has 2 alleles, both either 'A','C','G',or 'T' it is scored 1, otherwise it is 0.5 or 0
    def SEQUENCEQC(self):
        self.TOTAL_READS = len(self.GENOME)
        self.READ_SCORE = 0
        EXPECTED_BASES = ' ATCG'
        for N,S in enumerate(self.RSINDEX):
            RS_key = self.RSINDEX[N]
            SNP_READ = self.GENOME[RS_key]
            SNP_SCORE = 0
            a1 = SNP_READ[2]
            a2 = SNP_READ[3]
            A1_QC = EXPECTED_BASES.find(a1)
            A2_QC = EXPECTED_BASES.find(a2)
            if A1_QC > 0:
                SNP_SCORE = SNP_SCORE + 0.5
            if A2_QC > 0:
                SNP_SCORE = SNP_SCORE + 0.5
            self.READ_SCORE = self.READ_SCORE + SNP_SCORE
        self.READ_DEPTH = self.READ_SCORE / self.TOTAL_READS
        #8/27/21 this works!
#end of SNP_GENOME object

#Functions for handling SNP_GENOME objects:

#Compare 2 SNP_GENOMES
def GENOME_COMPARE(subjectA,subjectB):
    Genome_A_set = set(subjectA.RSINDEX)
    Genome_B_set = set(subjectB.RSINDEX)
    MATCH_SET = Genome_A_set.intersection(Genome_B_set)
    MATCH_LIST = list(MATCH_SET)
    MATCH_SIZE = len(MATCH_LIST)
    MATCH_DEPTH_A = MATCH_SIZE / subjectA.TOTAL_READS
    MATCH_DEPTH_B = MATCH_SIZE / subjectB.TOTAL_READS
    MATCH_SCORE = 0
    for N,S in enumerate(MATCH_LIST):
        RS_QUERY = MATCH_LIST[N]
        SNP_A = subjectA.GENOME[RS_QUERY]
        SNP_B = subjectB.GENOME[RS_QUERY]
        if SNP_A[2] == SNP_B[2]:
            MATCH_SCORE = MATCH_SCORE + 0.5
        if SNP_A[3] == SNP_B[3]:
            MATCH_SCORE = MATCH_SCORE + 0.5
    IDENTITY_SCORE = MATCH_SCORE / MATCH_SIZE
    MATCH_RESULT = [f'{subjectA.NAME}:{subjectB.NAME}',MATCH_SCORE,MATCH_SIZE,IDENTITY_SCORE,MATCH_DEPTH_A,MATCH_DEPTH_B]
    return MATCH_RESULT
#8/27 this works

#Compare 2 genomes by chromosome!
def CHROMOSOME_COMPARE(subjectA,subjectB):
    Genome_A_set = set(subjectA.RSINDEX)
    Genome_B_set = set(subjectB.RSINDEX)
    MATCH_SET = Genome_A_set.intersection(Genome_B_set)
    MATCH_LIST = list(MATCH_SET)
    '''Note:
        23&Me data labels chromosomes 1-22,'X','Y', and 'MT'
        Ancestry labels are 1-22,23&25 ,24 , and 26
        This could be because the 23&me files I have are from males
        while the Ancestry file is from a female
    '''
    CHR_INDEX = {}
    for N,S in enumerate(MATCH_LIST):
        RS_QUERY = MATCH_LIST[N]
        SNP_A = subjectA.GENOME[RS_QUERY]
        SNP_B = subjectB.GENOME[RS_QUERY]
        SNP_A_CHR = SNP_A[0]
        SNP_B_CHR = SNP_B[0]
        CHR_INDEX.update({SNP_A_CHR:SNP_B_CHR})
    return CHR_INDEX

def say_hello():
    print('Test Output')
    #8/9 this works - module must be in Python38\Lib\site-packages

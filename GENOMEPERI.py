'''
Eric Larsen's Genome Peri Module
Contains classes and functions for handling SNP data in TXT format
generated by 23&Me and Ancestry.com
2021
'''
#import dependencies
from re import finditer as SUBSTRING_ITERATOR
#8/29 - import single function instead of whole 're' module

'''SNP_GENOME class definition and associated functions'''
#8/27/21 - this is working
#9/7/21 - chromosome read counting works
class SNP_GENOME:
    #Object definition
    #Subject Name
    #Read TXT
    #TXT type (Ancestry or 23&Me)
    def __init__(self, name_string, TXT_address, TXT_TYPE):
        #Set variables
        self.NAME = name_string
        self.GENOME = {}
        self.CHROMOSOME_COUNT_LOG = {}
        self.CHROMOSOME_TOTAL = 0
        #set object data source
        if TXT_TYPE == 0: self.SOURCE = '23&Me'
        if TXT_TYPE == 1: self.SOURCE = 'ANCESTRY.com'
        #TO DO - support additional sources (and other species?)
        #LOAD TXT FILE
        '''Both file types have Read-me text that starts with '#'
        23&me has 20 lines (from files generated in 2017 and 2018)
        23&me has 4 columns (rsid,chromosome, position, and genotype)
        Ancestry data has 18+1 lines - header does not start with '#' (file generated in 2018)
        Ancestry has 5 columns (rsid,chromosome,position,allele1,allele2)'''
        GENOMEFILE = open(TXT_address)
        RAWTXTDATA = GENOMEFILE.readlines()
        GENOMEFILE.close()
        #RAWTXTDATA is every line including \t and \n
        #convert this data to a dictionary
        #structure {'rs###':[C,P,'A1','A2']}
        for N,S in enumerate(RAWTXTDATA):
            #load individual data line
            LINE = RAWTXTDATA[N]
            #Validator for chromosome read counting
            ENTRY_CONFIRMED = 0
            #test for '#' character
            if LINE[0] != '#':
                #strip '\n' from LINE
                NEWLINE_START = LINE.find('\n')
                TABBED_LINE = LINE[0:NEWLINE_START]
                #sort data by '\t' detection. Adapted from
                #https://stackoverflow.com/questions/4664850/how-to-find-all-occurrences-of-a-substring
                TAB_INDEX = [m.start() for m in SUBSTRING_ITERATOR('\t',TABBED_LINE)]
                #23&me formating
                #8/29 DONE: have this clean up chromosome IDs
                #use Integers 1-22, 23 for 'X', 24 for 'Y', and 26 for 'MT'
                #get a count of chromosomes - for potential future compatibiltiy with nonhuman data
                ChromosomeLookup = {'X':23, 'Y':24, 'MT':26}
                if TXT_TYPE == 0:
                    RS_key = LINE[0:TAB_INDEX[0]]
                    #Chromosome can be 'X' 'Y' or 'mt' so convert it to INT
                    CHROMOSOME = TABBED_LINE[TAB_INDEX[0]+1:TAB_INDEX[1]]
                    if CHROMOSOME == 'X' or CHROMOSOME =='Y' or CHROMOSOME =='MT':
                        CHROMOSOME = ChromosomeLookup[CHROMOSOME]
                    else:
                        CHROMOSOME = int(CHROMOSOME)

                    #build self.GENOME dictionary entry from 23&Me format
                    GENE_POSITION = int(TABBED_LINE[TAB_INDEX[1]+1:TAB_INDEX[2]])
                    allele1 = TABBED_LINE[TAB_INDEX[2]+1:TAB_INDEX[2]+2]
                    allele2 = TABBED_LINE[TAB_INDEX[2]+2:TAB_INDEX[2]+3]
                    RS_list = [CHROMOSOME, GENE_POSITION, allele1, allele2]
                    DICT_ENTRY = {RS_key:RS_list}
                    ENTRY_CONFIRMED = 1
                    #update self.GENOME dictionary
                    self.GENOME.update(DICT_ENTRY)
                    #Per Chromosome Read Counting
                    try:
                        CHR_READ_COUNT = self.CHROMOSOME_COUNT_LOG[CHROMOSOME]
                        CHR_READ_COUNT = CHR_READ_COUNT +1
                        NEW_CHR_READ_ENTRY = {CHROMOSOME:CHR_READ_COUNT}
                        self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                    #expect a KeyError if this Chromosome is not logged
                    except KeyError:
                        NEW_CHR_READ_ENTRY = {CHROMOSOME:1}
                        self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                        #Increment Chromosome read counter
                        self.CHROMOSOME_TOTAL = self.CHROMOSOME_TOTAL + 1 

                #Ancestry.com formating
                if TXT_TYPE == 1:
                    RS_key = TABBED_LINE[0:TAB_INDEX[0]]
                    #Detect header line
                    if RS_key != 'rsid':
                        CHROMOSOME = TABBED_LINE[TAB_INDEX[0]+1:TAB_INDEX[1]]
                        #Ancestry IDs chromosomes with an int by default
                        #TO DO: have separate ids for 'X1' and 'X2' (lack datasets to be definitive)
                        CHROMOSOME = int(CHROMOSOME)
                        #Consolidate all 'X' chromosome entries into one int ID
                        if CHROMOSOME == 25:
                            CHROMOSOME = 23

                        #build self.GENOME dictionary entry from Ancestry.com format
                        GENE_POSITION = int(TABBED_LINE[TAB_INDEX[1]+1:TAB_INDEX[2]])
                        allele1 = TABBED_LINE[TAB_INDEX[2]+1:TAB_INDEX[3]]
                        allele2 = TABBED_LINE[TAB_INDEX[3]+1:TAB_INDEX[3]+2]
                        RS_list = [CHROMOSOME, GENE_POSITION, allele1, allele2]
                        DICT_ENTRY = {RS_key:RS_list}
                        ENTRY_CONFIRMED = 1
                        #update self.GENOME dictionary
                        self.GENOME.update(DICT_ENTRY)
                        #Per Chromosome Read Counting
                        try:
                            CHR_READ_COUNT = self.CHROMOSOME_COUNT_LOG[CHROMOSOME]
                            CHR_READ_COUNT = CHR_READ_COUNT +1
                            NEW_CHR_READ_ENTRY = {CHROMOSOME:CHR_READ_COUNT}
                            self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                        #expect a KeyError if this Chromosome is not logged
                        except KeyError:
                            NEW_CHR_READ_ENTRY = {CHROMOSOME:1}
                            self.CHROMOSOME_COUNT_LOG.update(NEW_CHR_READ_ENTRY)
                            #Increment Chromosome read counter
                            self.CHROMOSOME_TOTAL = self.CHROMOSOME_TOTAL + 1


        #make list of RSIDs
        self.RSINDEX = list(self.GENOME)
    #end of INIT
    
    #This function will go through each entry and score sequence quality
    #IE: if SNP has 2 alleles, both either 'A','C','G',or 'T' it is scored 1, otherwise it is 0.5 or 0  
    def SEQUENCEQC(self):
        self.TOTAL_READS = len(self.GENOME)
        self.READ_SCORE = 0
        self.CHROMOSOME_QC = {}
        EXPECTED_BASES = ' ATCG'
        for N,S in enumerate(self.RSINDEX):
            RS_key = self.RSINDEX[N]
            SNP_READ = self.GENOME[RS_key] 
            SNP_SCORE = 0
            a1 = SNP_READ[2]
            a2 = SNP_READ[3]
            A1_QC = EXPECTED_BASES.find(a1)
            A2_QC = EXPECTED_BASES.find(a2)
            if A1_QC > 0:
                SNP_SCORE = SNP_SCORE + 0.5
            if A2_QC > 0:
                SNP_SCORE = SNP_SCORE + 0.5
            self.READ_SCORE = self.READ_SCORE + SNP_SCORE
            #Chromosome QC
            Chromosome = SNP_READ[0]
            try:
                Chromosome_score = self.CHROMOSOME_QC[Chromosome]
                Chromosome_score = Chromosome_score + SNP_SCORE
                CHROMOSOME_QC_ENTRY = {Chromosome:Chromosome_score}
                self.CHROMOSOME_QC.update(CHROMOSOME_QC_ENTRY)
            #Initialize the chromosome entry if it does not yet exist
            except KeyError:
                Chromosome_score = SNP_SCORE
                CHROMOSOME_QC_ENTRY = {Chromosome:Chromosome_score}
                self.CHROMOSOME_QC.update(CHROMOSOME_QC_ENTRY)
            
        self.READ_DEPTH = self.READ_SCORE / self.TOTAL_READS

    #Display Quality Control Statistics
    def QC_REPORT(self):
        #9/8/21 for now human only
        #Whole Genome report:
        print(f'Subject {self.NAME} DNA report has {self.TOTAL_READS} SNP records')
        print(f'The quality score of the {self.TOTAL_READS} SNPs is {self.READ_SCORE}')
        QUALITY_PERCENTAGE = 100*round(self.READ_DEPTH,4)
        print(f'This DNA report quality is {QUALITY_PERCENTAGE}%')
        print('***\n')
        #Individual Chromosome Report:
        String_dict = {23:'X', 24:'Y', 26:'MT'}
        for n in range(1,25):
            CHROMOSOME_SCORE = self.CHROMOSOME_QC[n]
            CHROMOSOME_READS = self.CHROMOSOME_COUNT_LOG[n]
            CHROMOSOME_DEPTH = CHROMOSOME_SCORE/CHROMOSOME_READS
            CHROMOSOME_QUAL_PERCENT = 100*round(CHROMOSOME_DEPTH,3)
            try:
                Chromosome_String = String_dict[n]
            except KeyError:
                Chromosome_String = str(n)
            print(f'Chromosome {Chromosome_String} contains {CHROMOSOME_READS} SNPS')
            print(f'Chromosome {Chromosome_String} quality score: {CHROMOSOME_SCORE}')
            print(f'Chromosome {Chromosome_String} report quality is {CHROMOSOME_QUAL_PERCENT}%')
            print('***\n')
        #MT DNA
        MT_SCORE = self.CHROMOSOME_QC[26]
        MT_READS = self.CHROMOSOME_COUNT_LOG[26]
        MT_DEPTH = MT_SCORE/MT_READS
        MT_QUAL_PERCENT = 100*round(MT_DEPTH,3)
        print(f'Mitochondrial DNA contains {MT_READS} SNPS')
        print(f'Mitochondrial DNA quality score: {MT_SCORE}')
        print(f'Mitochondrial DNA report quality is {MT_QUAL_PERCENT}%')
        print('***\n')
        
#end of SNP_GENOME object & functions

'''Functions for handling SNP_GENOME objects:'''
#Convert two genomes into a set, find the intersection,
# and return a list of common rsids
#called by GENOME_COMPARE() and CHROMOSOME_COMPARE()
def SNP_SET_INTERSECT(subjectA,subjectB):
    RSID_A_set = set(subjectA.RSINDEX)
    RSID_B_set = set(subjectB.RSINDEX)
    INTERSECT_SET = RSID_A_set.intersection(RSID_B_set)
    INTERSECT_LIST = list(INTERSECT_SET)
    return INTERSECT_LIST

#Makes an identity score between 2 SNPs pulled from SNP_GENOME.GENOME{}
#to be called by subsequent functions
def SNP_GENOTYPE_SCORE(SNP_A,SNP_B):
    #input format: [C,P,'A1','A2']
    FINAL_SCORE = 0
    #Subject A data
    SUBJECT_A_CHROMOSOME = SNP_A[0]
    SUBJECT_A_POSITION = SNP_A[1]
    SUBJECT_A_ALLELE_1 = SNP_A[2]
    SUBJECT_A_ALLELE_2 = SNP_A[3]
    #Subject B data
    SUBJECT_B_CHROMOSOME = SNP_B[0]
    SUBJECT_B_POSITION = SNP_B[1]
    SUBJECT_B_ALLELE_1 = SNP_B[2]
    SUBJECT_B_ALLELE_2 = SNP_B[3]
    #Confirm position before proceeding
    if SUBJECT_A_POSITION == SUBJECT_B_POSITION and SUBJECT_A_CHROMOSOME == SUBJECT_B_CHROMOSOME:
        #check for exact mstch
        if (SUBJECT_A_ALLELE_1 + SUBJECT_A_ALLELE_2) == (SUBJECT_B_ALLELE_1 + SUBJECT_B_ALLELE_2):
            FINAL_SCORE = 1
        else:
            ScoreAllele1_1 = int(SUBJECT_A_ALLELE_1 == SUBJECT_B_ALLELE_1)
            ScoreAllele1_2 = int(SUBJECT_A_ALLELE_1 == SUBJECT_B_ALLELE_2)
            ScoreAllele2_1 = int(SUBJECT_A_ALLELE_2 == SUBJECT_B_ALLELE_1)
            ScoreAllele2_2 = int(SUBJECT_A_ALLELE_2 == SUBJECT_B_ALLELE_2)
            FINAL_SCORE = 0.25*(ScoreAllele1_1 + ScoreAllele1_2 + ScoreAllele2_1 + ScoreAllele2_2)    
    return FINAL_SCORE

#Compare 2 whole SNP_GENOMES
def GENOME_COMPARE(subjectA,subjectB):
    MATCH_LIST = SNP_SET_INTERSECT(subjectA,subjectB)
    MATCH_SIZE = len(MATCH_LIST)
    MATCH_DEPTH_A = MATCH_SIZE / subjectA.TOTAL_READS
    MATCH_DEPTH_B = MATCH_SIZE / subjectB.TOTAL_READS
    MATCH_SCORE = 0
    for N,S in enumerate(MATCH_LIST):
        RS_QUERY = MATCH_LIST[N]
        SNP_A = subjectA.GENOME[RS_QUERY]
        SNP_B = subjectB.GENOME[RS_QUERY]
        SINGLE_SNP_SCORE = SNP_GENOTYPE_SCORE(SNP_A,SNP_B)
        MATCH_SCORE = MATCH_SCORE + SINGLE_SNP_SCORE
    IDENTITY_SCORE = MATCH_SCORE / MATCH_SIZE
    MATCH_RESULT = [f'{subjectA.NAME}:{subjectB.NAME}',MATCH_SCORE,MATCH_SIZE,IDENTITY_SCORE,MATCH_DEPTH_A,MATCH_DEPTH_B]
    return MATCH_RESULT

#Compare 2 SNP_GENOMES by chromosome
def CHROMOSOME_COMPARE(subjectA,subjectB):
    #Format of CHR_SCORE_INDEX dictionary
    #{CHR_INT: [MATCH_SCORE,MATCH_SIZE,SubjectA_Chromosome_Reads,SubjectB_Chromosome_Reads]}
    CHR_SCORE_INDEX = {}
    #Confirm Subjects have identical Chromosome Counts
    if subjectA.CHROMOSOME_TOTAL == subjectB.CHROMOSOME_TOTAL:
        MATCH_LIST = SNP_SET_INTERSECT(subjectA,subjectB)
        #Go through each matched entry and use chromosome ID to bin data
        for N,S in enumerate(MATCH_LIST):
            RS_QUERY = MATCH_LIST[N]
            SNP_A = subjectA.GENOME[RS_QUERY]
            SNP_B = subjectB.GENOME[RS_QUERY]
            #Confirm Chromosome Match
            if SNP_A[0] == SNP_B[0]:
                Chromosome = SNP_A[0]
                #SCORE GENOTYPE
                SINGLE_SNP_SCORE = SNP_GENOTYPE_SCORE(SNP_A,SNP_B)
                #Has this chromosome been added to CHR_SCORE_INDEX?
                try:
                    CHR_MATCH_DATA = CHR_SCORE_INDEX[Chromosome]
                    #Update score for this chromosome
                    CHR_MATCH_DATA[0] = CHR_MATCH_DATA[0] + SINGLE_SNP_SCORE
                    #Increment # of matched RSIDs in Chromosome
                    CHR_MATCH_DATA[1] = CHR_MATCH_DATA[1] + 1
                    UPDATE_SCORE = {Chromosome:CHR_MATCH_DATA}
                    CHR_SCORE_INDEX.update(UPDATE_SCORE)
                #Initialize CHR_SCORE_INDEX entry when none exists
                except KeyError:
                    SubjectA_CHR_READ_COUNT = subjectA.CHROMOSOME_COUNT_LOG[Chromosome]
                    SubjectB_CHR_READ_COUNT = subjectB.CHROMOSOME_COUNT_LOG[Chromosome]
                    CHR_MATCH_START = [SINGLE_SNP_SCORE, 1, SubjectA_CHR_READ_COUNT, SubjectB_CHR_READ_COUNT]
                    INITIAL_SCORE = {Chromosome:CHR_MATCH_START}
                    CHR_SCORE_INDEX.update(INITIAL_SCORE)
    else:
        print(f'WARNING:{subjectA.NAME} does not have the same chromosome count as {subjectB.NAME}\nNo comparison made.') 
    return CHR_SCORE_INDEX

#function for displaying CHR_SCORE_INDEX results
def DISPLAY_CHROMOSOME_SCORES(subjectA, subjectB, CHR_SCORE_INDEX):
    #dictionary for using string names
    String_dict = {23:'X', 24:'Y', 26:'MT'}
    SubjectA_string = subjectA.NAME
    SubjectB_string = subjectB.NAME
    #FOR NOW THIS ONLY SUPPORTS HUMAN DATA (1-24, 26)
    #Display Chromosome Results
    for n in range(1,25):
        #X & Y case
        try:
            CHR_NAME = String_dict[n]
            CHR_RESULTS = CHR_SCORE_INDEX[n]
            CHR_IDENTITY_SCORE = 100*(CHR_RESULTS[0] / CHR_RESULTS[1])
            subject_A_depth = 100*(CHR_RESULTS[1] / CHR_RESULTS[2])
            subject_B_depth = 100*(CHR_RESULTS[1] / CHR_RESULTS[3])
            print(f'{SubjectA_string} Chromosome {CHR_NAME} is {CHR_IDENTITY_SCORE}% identical to {SubjectB_string} Chromosome {CHR_NAME}')
            print(f'This match covers {subject_A_depth}% of {SubjectA_string} Chromosome {CHR_NAME}')
            print(f'This match covers {subject_B_depth}% of {SubjectB_string} Chromosome {CHR_NAME}')
            print('***\n')
        #Chromosomes 1-22
        except KeyError:
            CHR_RESULTS = CHR_SCORE_INDEX[n]
            CHR_IDENTITY_SCORE = 100*(CHR_RESULTS[0] / CHR_RESULTS[1])
            subject_A_depth = 100*(CHR_RESULTS[1] / CHR_RESULTS[2])
            subject_B_depth = 100*(CHR_RESULTS[1] / CHR_RESULTS[3])
            print(f'{SubjectA_string} Chromosome {n} is {CHR_IDENTITY_SCORE}% identical to {SubjectB_string} Chromosome {n}')
            print(f'This match covers {subject_A_depth}% of {SubjectA_string} Chromosome {n}')
            print(f'This match covers {subject_B_depth}% of {SubjectB_string} Chromosome {n}')
            print('***\n')

    #Display MT DNA result
    MT_RESULTS = CHR_SCORE_INDEX[26]
    MT_IDENTITY_SCORE = 100*(MT_RESULTS[0] / MT_RESULTS[1])
    subject_A_depth = 100*(MT_RESULTS[1] / CHR_RESULTS[2])
    subject_B_depth = 100*(MT_RESULTS[1] / CHR_RESULTS[3])
    print(f'{SubjectA_string} Mitochondria DNA is {MT_IDENTITY_SCORE}% identical to {SubjectB_string} Mitochondria DNA')
    print(f'This match covers {subject_A_depth}% of {SubjectA_string} Mitochondria DNA')
    print(f'This match covers {subject_B_depth}% of {SubjectB_string} Mitochondria DNA')
    print('***\n')
    return
#End of SNP_GENOME comparison functions

'''
Functions for reporting on RSID groups
'''
#SNP_REPORTING - function that generates a report from an input list of RSIDs
def SNP_REPORTING(SUBJECT,QUERY_LIST):
    #loop through every RS string in the QUERY_LIST
    REPORT_LISTING = []
    QUERY_SIZE = len(QUERY_LIST)
    HIT = 0
    MISS = 0
    #String for coving absent RSIDs
    NULL_STRING = 'NONE'
    for N,S in enumerate(QUERY_LIST):
        RS_QUERY = QUERY_LIST[N]
        #Look up query RSID string in SUBJECT.GENOME dictionary
        try:
            RS_RESULT = SUBJECT.GENOME[RS_QUERY]
            #Individual entry format ['NAME','RSID','ALLELE1','ALLELE2']
            REPORT_ENTRY = [SUBJECT.NAME, RS_QUERY, RS_RESULT[2], RS_RESULT[3]]
            REPORT_LISTING.append(REPORT_ENTRY)
            HIT = HIT + 1
        except KeyError:
            REPORT_ENTRY = [SUBJECT.NAME, RS_QUERY, NULL_STRING, NULL_STRING]
            REPORT_LISTING.append(REPORT_ENTRY)
            MISS = MISS + 1
    #Include values for Quality COntrol
    #FINAL_ENTRY format ['NAME', RSID_TOTAL, HITS, MISSES]
    FINAL_ENTRY = [SUBJECT.NAME, QUERY_SIZE, HIT, MISS]
    REPORT_LISTING.append(FINAL_ENTRY)
    return REPORT_LISTING
#9/9/21 - this is working

#TO DO - function that calls entrez / dbSNP for additional data on
#           specific SNPs (will introduce additional dependencies - FORK?)
#TO DO - 'sequence builder' function - makes a best guess at a specific gene
#           sequence from an individual's SNP genome

'''Quick module test'''
def say_hello():
    print('Test Output')
#8/9 this works - module must be in Python38\Lib\site-packages
